<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ruby | Mr. Anderson]]></title>
  <link href="http://kmc653.github.io/blog/categories/ruby/atom.xml" rel="self"/>
  <link href="http://kmc653.github.io/"/>
  <updated>2015-02-01T21:29:17+08:00</updated>
  <id>http://kmc653.github.io/</id>
  <author>
    <name><![CDATA[Kai-Min Change]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Procfile and Foreman]]></title>
    <link href="http://kmc653.github.io/blog/2015/02/01/procfile-and-foreman/"/>
    <updated>2015-02-01T17:39:07+08:00</updated>
    <id>http://kmc653.github.io/blog/2015/02/01/procfile-and-foreman</id>
    <content type="html"><![CDATA[<h1>Procfile</h1>

<p><code>Procfile</code> is a text file, placed in the root of the Rails application, used to declare what commands are run by dynos of the application on the Heroku. We can use Procfile to declare different kind of process type. Each process type is a declaration of command that is executed when a dyno of that process type is started.</p>

<p>The following code is the format of process type, one process per line.
<code>ruby
&lt;process type&gt;: &lt;command&gt;
</code></p>

<p>For example,
<code>ruby
web: bundle exec unicorn -p $PORT -c ./config/unicorn.rb
</code></p>

<h1>Foreman</h1>

<p>When we develope and debug an applicaion, the local developement environment is as similar as remote environments will avoid us from expending extra time to fix errors. <code>Foreman</code> is a command-line tool for running <code>Procfile</code> to execute application, which would make local emvironment works like remote&rsquo;s.</p>

<p>Type <code>foreman start</code> in command-line to execute <code>Foreman</code>
<code>
$ foreman start
21:12:35 web.1  | started with pid 25658
21:12:36 web.1  | I, [2015-02-01T21:12:36.014308 #25658]  INFO -- : Refreshing Gem list
21:12:38 web.1  | I, [2015-02-01T21:12:38.087552 #25658]  INFO -- : listening on addr=0.0.0.0:5000 fd=10
21:12:38 web.1  | I, [2015-02-01T21:12:38.256511 #25658]  INFO -- : master process ready
</code>
We can see the application running on the <a href="http://localhost:5000">http://localhost:5000</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Usage of strip, slice and split Methods of String]]></title>
    <link href="http://kmc653.github.io/blog/2014/12/27/the-usage-of-method-number-strip-and-slice-of-string/"/>
    <updated>2014-12-27T19:49:30+08:00</updated>
    <id>http://kmc653.github.io/blog/2014/12/27/the-usage-of-method-number-strip-and-slice-of-string</id>
    <content type="html"><![CDATA[<h1>Strip</h1>

<p>The method <code>strip</code> is used in a string. Returning the same content of string with leading and trailing whitespace removed.</p>

<pre><code>"   Kevin   ".strip     #=&gt; "Kevin"
</code></pre>

<p>The string will be changed if we use <code>strip!</code>. Return <code>nil</code> means the string was not altered.</p>

<pre><code>"Kevin".strip!     #=&gt; nil
</code></pre>

<h1>Slice</h1>

<p>The method <code>slice</code> is used in a string.<br/>
* <em>slice( index ) => str or nil</em><br/>
* <em>slice( start, length ) => str or nil</em><br/>
* <em>slice( range ) => str or nil</em><br/>
* <em>slice( regexp ) => str or nil</em><br/>
* <em>slice( regexp, capture ) => str or nil</em><br/>
* <em>slice( match_str ) => str or nil</em></p>

<pre><code>"kevin".slice(3)     #=&gt; "i"  
"kevin".slice(3, 2)     #=&gt; "in"  
"kevin".slice(1..3)     #=&gt; "evi"  
"kevinaeiou".slice(/[aeiou][0...9]/)
"kevin".slice("v")     #=&gt; "v"
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Usage of Collect &amp; Map Methods]]></title>
    <link href="http://kmc653.github.io/blog/2014/12/21/the-usage-of-collect-and-map-methods/"/>
    <updated>2014-12-21T22:57:15+08:00</updated>
    <id>http://kmc653.github.io/blog/2014/12/21/the-usage-of-collect-and-map-methods</id>
    <content type="html"><![CDATA[<h1>Collect</h1>

<ul>
<li><em>collect { | item | block } => array</em></li>
<li><em>collect => Enumerator</em></li>
</ul>


<p>The method <code>collect</code> is used in an array. Returns a new array with the results of executing block once for each element in array.<br/>
If no block is given, an enummerator is returned instead.</p>

<pre><code>['a', 'b', 'c'].collect{ |letter| letter.capitalize }     #=&gt; ["A", "B", "C"]
</code></pre>

<p>There is a concise way doing the same work:</p>

<pre><code>['a', 'b', 'c'].collect(&amp;:capitalize)     #=&gt; ["A", "B", "C"]
</code></pre>

<p>The element will be replaced with the value returned by block if adding a <code>!</code></p>

<pre><code>a = ['a', 'b', 'c'].collect!(&amp;:capitalize)
a     #=&gt; ["A", "B", "C"]
</code></pre>

<h1>Map</h1>

<ul>
<li><em>map { | item | block } => array</em></li>
<li><em>map => Enumerator</em></li>
</ul>


<p>The method <code>map</code> is also used in an array.</p>

<pre><code>a = ['a', 'b', 'c']
a.map { |x| x + x }     #=&gt; ["aa", "bb", "cc"]
</code></pre>

<p>There is also a shorthand way:</p>

<pre><code>['a', 'b', 'c'].map(&amp;:capitalize)     #=&gt; ["A", "B", "C"]
</code></pre>

<p>The element will be replaced with the value returned by block if adding a <code>!</code></p>

<pre><code>a = ['A', 'B', 'C']
a.map!(&amp;:downcase)
a     #=&gt; ["a", "b", "c"]
</code></pre>
]]></content>
  </entry>
  
</feed>
